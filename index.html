
      class Game {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        
        this.setup();
        this.initGame();
    }

    setup() {
        // Renderer setup
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setClearColor(0x87CEEB);
        document.getElementById('gameContainer').appendChild(this.renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        this.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(50, 50, 25);
        this.scene.add(directionalLight);

        // Create game environment
        this.createEnvironment();
        
        // Game state
        this.score = 0;
        this.enemies = [];
        this.gameRunning = false;
        this.enemySpawnTimer = 0;
        
        this.setupEventListeners();
    }

    createEnvironment() {
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3A8C3A });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        this.scene.add(ground);

        // Create some obstacles
        const obstacles = [
            { x: 10, z: 10, size: 3 },
            { x: -15, z: 5, size: 2 },
            { x: 5, z: -20, size: 4 },
            { x: -20, z: -15, size: 3 }
        ];

        obstacles.forEach(obs => {
            const obstacle = Utils.createBox(obs.size, obs.size, obs.size, 0x8B4513, obs.x, obs.size/2, obs.z);
            this.scene.add(obstacle);
        });
    }

    setupEventListeners() {
        document.getElementById('startBtn').addEventListener('click', () => {
            this.startGame();
        });

        document.getElementById('restartBtn').addEventListener('click', () => {
            this.restartGame();
        });

        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    startGame() {
        document.getElementById('startScreen').style.display = 'none';
        this.gameRunning = true;
        
        // Create player
        this.player = new Player(this);
        
        // Start game loop
        this.gameLoop();
    }

    gameOver() {
        this.gameRunning = false;
        document.getElementById('finalScore').textContent = `Score: ${this.score}`;
        document.getElementById('gameOverScreen').style.display = 'flex';
    }

    restartGame() {
        // Reset scene
        while(this.scene.children.length > 0){ 
            this.scene.remove(this.scene.children[0]); 
        }
        
        // Reset game state
        this.score = 0;
        this.enemies = [];
        
        // Recreate environment
        this.createEnvironment();
        
        // Hide game over screen
        document.getElementById('gameOverScreen').style.display = 'none';
        
        // Start new game
        this.startGame();
    }

    increaseScore(points) {
        this.score += points;
        document.getElementById('score').textContent = `Score: ${this.score}`;
    }

    spawnEnemy() {
        const angle = Math.random() * Math.PI * 2;
        const distance = 30;
        const x = Math.cos(angle) * distance;
        const z = Math.sin(angle) * distance;
        
        const enemy = new Enemy(this, x, z);
        this.enemies.push(enemy);
    }

    gameLoop() {
        if (!this.gameRunning) return;

        // Update player
        this.player.update();

        // Spawn enemies
        this.enemySpawnTimer++;
        if (this.enemySpawnTimer > 180 && this.enemies.length < 10) { // Spawn every 3 seconds
            this.spawnEnemy();
            this.enemySpawnTimer = 0;
        }

        // Update enemies
        this.enemies.forEach((enemy, index) => {
            enemy.update();
        });

        // Remove dead enemies
        this.enemies = this.enemies.filter(enemy => enemy.health > 0);

        // Render
        this.renderer.render(this.scene, this.camera);

        // Continue loop
        requestAnimationFrame(() => this.gameLoop());
    }

    initGame() {
        // Initial setup complete
        console.log('Game initialized');
    }
}

// Start the game when page loads
window.addEventListener('load', () => {
    window.game = new Game();
});
